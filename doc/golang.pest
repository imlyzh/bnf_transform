newline = { UNDEFINED }
unicode_char = { UNDEFINED }
unicode_letter = { UNDEFINED }
unicode_digit = { UNDEFINED }
letter = { unicode_letter | "_" }
decimal_digit = { '0'..'9' }
binary_digit = { "0" | "1" }
octal_digit = { '0'..'7' }
hex_digit = { '0'..'9' | 'A'..'F' | 'a'..'f' }
identifier = { letter ~ (letter | unicode_digit)* }
int_lit = { decimal_lit | binary_lit | octal_lit | hex_lit }
decimal_lit = { "0" | ('1'..'9') ~ (("_")? ~ decimal_digits)? }
binary_lit = { "0" ~ ("b" | "B") ~ ("_")? ~ binary_digits }
octal_lit = { "0" ~ ("o" | "O")? ~ ("_")? ~ octal_digits }
hex_lit = { "0" ~ ("x" | "X") ~ ("_")? ~ hex_digits }
decimal_digits = { decimal_digit ~ (("_")? ~ decimal_digit)* }
binary_digits = { binary_digit ~ (("_")? ~ binary_digit)* }
octal_digits = { octal_digit ~ (("_")? ~ octal_digit)* }
hex_digits = { hex_digit ~ (("_")? ~ hex_digit)* }
float_lit = { decimal_float_lit | hex_float_lit }
decimal_float_lit = { decimal_digits ~ "." ~ (decimal_digits)? ~ (decimal_exponent)? | decimal_digits ~ decimal_exponent | "." ~ decimal_digits ~ (decimal_exponent)? }
decimal_exponent = { ("e" | "E") ~ ("+" | "-")? ~ decimal_digits }
hex_float_lit = { "0" ~ ("x" | "X") ~ hex_mantissa ~ hex_exponent }
hex_mantissa = { ("_")? ~ hex_digits ~ "." ~ (hex_digits)? | ("_")? ~ hex_digits | "." ~ hex_digits }
hex_exponent = { ("p" | "P") ~ ("+" | "-")? ~ decimal_digits }
imaginary_lit = { (decimal_digits | int_lit | float_lit) ~ "i" }
rune_lit = { "'" ~ (unicode_value | byte_value) ~ "'" }
unicode_value = { unicode_char | little_u_value | big_u_value | escaped_char }
byte_value = { octal_byte_value | hex_byte_value }
octal_byte_value = { "\\" ~ octal_digit ~ octal_digit ~ octal_digit }
hex_byte_value = { "\\" ~ "x" ~ hex_digit ~ hex_digit }
little_u_value = { "\\" ~ "u" ~ hex_digit ~ hex_digit ~ hex_digit ~ hex_digit }
big_u_value = { "\\" ~ "U" ~ hex_digit ~ hex_digit ~ hex_digit ~ hex_digit ~ hex_digit ~ hex_digit ~ hex_digit ~ hex_digit }
escaped_char = { "\\" ~ ("a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" | "'" | "\"") }
string_lit = { raw_string_lit | interpreted_string_lit }
raw_string_lit = { "`" ~ (unicode_char | newline)* ~ "`" }
interpreted_string_lit = { "\"" ~ (unicode_value | byte_value)* ~ "\"" }
type = { typename | typelit | "(" ~ type ~ ")" }
typename = { identifier | qualifiedident }
typelit = { arraytype | structtype | pointertype | functiontype | interfacetype | slicetype | maptype | channeltype }
arraytype = { "[" ~ arraylength ~ "]" ~ elementtype }
arraylength = { expression }
elementtype = { type }
slicetype = { "[" ~ "]" ~ elementtype }
structtype = { "struct" ~ "{" ~ (fielddecl ~ ";")* ~ "}" }
fielddecl = { (identifierlist ~ type | embeddedfield) ~ (tag)? }
embeddedfield = { ("*")? ~ typename }
tag = { string_lit }
pointertype = { "*" ~ basetype }
basetype = { type }
functiontype = { "func" ~ signature }
signature = { parameters ~ (result)? }
result = { parameters | type }
parameters = { "(" ~ (parameterlist ~ (",")?)? ~ ")" }
parameterlist = { parameterdecl ~ ("," ~ parameterdecl)* }
parameterdecl = { (identifierlist)? ~ ("...")? ~ type }
interfacetype = { "interface" ~ "{" ~ ((methodspec | interfacetypename) ~ ";")* ~ "}" }
methodspec = { methodname ~ signature }
methodname = { identifier }
interfacetypename = { typename }
maptype = { "map" ~ "[" ~ keytype ~ "]" ~ elementtype }
keytype = { type }
channeltype = { ("chan" | "chan" ~ "<-" | "<-" ~ "chan") ~ elementtype }
block = { "{" ~ statementlist ~ "}" }
statementlist = { (statement ~ ";")* }
declaration = { constdecl | typedecl | vardecl }
topleveldecl = { declaration | functiondecl | methoddecl }
constdecl = { "const" ~ (constspec | "(" ~ (constspec ~ ";")* ~ ")") }
constspec = { identifierlist ~ ((type)? ~ "=" ~ expressionlist)? }
identifierlist = { identifier ~ ("," ~ identifier)* }
expressionlist = { expression ~ ("," ~ expression)* }
typedecl = { "type" ~ (typespec | "(" ~ (typespec ~ ";")* ~ ")") }
typespec = { aliasdecl | typedef }
aliasdecl = { identifier ~ "=" ~ type }
typedef = { identifier ~ type }
vardecl = { "var" ~ (varspec | "(" ~ (varspec ~ ";")* ~ ")") }
varspec = { identifierlist ~ (type ~ ("=" ~ expressionlist)? | "=" ~ expressionlist) }
shortvardecl = { identifierlist ~ ":=" ~ expressionlist }
functiondecl = { "func" ~ functionname ~ signature ~ (functionbody)? }
functionname = { identifier }
functionbody = { block }
methoddecl = { "func" ~ receiver ~ methodname ~ signature ~ (functionbody)? }
receiver = { parameters }
operand = { literal | operandname | "(" ~ expression ~ ")" }
literal = { basiclit | compositelit | functionlit }
basiclit = { int_lit | float_lit | imaginary_lit | rune_lit | string_lit }
operandname = { identifier | qualifiedident }
qualifiedident = { packagename ~ "." ~ identifier }
compositelit = { literaltype ~ literalvalue }
literaltype = { structtype | arraytype | "[" ~ "..." ~ "]" ~ elementtype | slicetype | maptype | typename }
literalvalue = { "{" ~ (elementlist ~ (",")?)? ~ "}" }
elementlist = { keyedelement ~ ("," ~ keyedelement)* }
keyedelement = { (key ~ ":")? ~ element }
key = { fieldname | expression | literalvalue }
fieldname = { identifier }
element = { expression | literalvalue }
functionlit = { "func" ~ signature ~ functionbody }
primaryexpr = { operand | conversion | methodexpr | primaryexpr ~ selector | primaryexpr ~ index | primaryexpr ~ slice | primaryexpr ~ typeassertion | primaryexpr ~ arguments }
selector = { "." ~ identifier }
index = { "[" ~ expression ~ "]" }
slice = { "[" ~ (expression)? ~ ":" ~ (expression)? ~ "]" | "[" ~ (expression)? ~ ":" ~ expression ~ ":" ~ expression ~ "]" }
typeassertion = { "." ~ "(" ~ type ~ ")" }
arguments = { "(" ~ ((expressionlist | type ~ ("," ~ expressionlist)?) ~ ("...")? ~ (",")?)? ~ ")" }
methodexpr = { receivertype ~ "." ~ methodname }
receivertype = { type }
expression = { unaryexpr | expression ~ binary_op ~ expression }
unaryexpr = { primaryexpr | unary_op ~ unaryexpr }
binary_op = { "||" | "&&" | rel_op | add_op | mul_op }
rel_op = { "==" | "!=" | "<" | "<=" | ">" | ">=" }
add_op = { "+" | "-" | "|" | "^" }
mul_op = { "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" }
unary_op = { "+" | "-" | "!" | "^" | "*" | "&" | "<-" }
conversion = { type ~ "(" ~ expression ~ (",")? ~ ")" }
statement = { declaration | labeledstmt | simplestmt | gostmt | returnstmt | breakstmt | continuestmt | gotostmt | fallthroughstmt | block | ifstmt | switchstmt | selectstmt | forstmt | deferstmt }
simplestmt = { emptystmt | expressionstmt | sendstmt | incdecstmt | assignment | shortvardecl }
emptystmt = { UNDEFINED }
labeledstmt = { label ~ ":" ~ statement }
label = { identifier }
expressionstmt = { expression }
sendstmt = { channel ~ "<-" ~ expression }
channel = { expression }
incdecstmt = { expression ~ ("++" | "--") }
assignment = { expressionlist ~ assign_op ~ expressionlist }
assign_op = { (add_op | mul_op)? ~ "=" }
ifstmt = { "if" ~ (simplestmt ~ ";")? ~ expression ~ block ~ ("else" ~ (ifstmt | block))? }
switchstmt = { exprswitchstmt | typeswitchstmt }
exprswitchstmt = { "switch" ~ (simplestmt ~ ";")? ~ (expression)? ~ "{" ~ (exprcaseclause)* ~ "}" }
exprcaseclause = { exprswitchcase ~ ":" ~ statementlist }
exprswitchcase = { "case" ~ expressionlist | "default" }
typeswitchstmt = { "switch" ~ (simplestmt ~ ";")? ~ typeswitchguard ~ "{" ~ (typecaseclause)* ~ "}" }
typeswitchguard = { (identifier ~ ":=")? ~ primaryexpr ~ "." ~ "(" ~ "type" ~ ")" }
typecaseclause = { typeswitchcase ~ ":" ~ statementlist }
typeswitchcase = { "case" ~ typelist | "default" }
typelist = { type ~ ("," ~ type)* }
forstmt = { "for" ~ (condition | forclause | rangeclause)? ~ block }
condition = { expression }
forclause = { (initstmt)? ~ ";" ~ (condition)? ~ ";" ~ (poststmt)? }
initstmt = { simplestmt }
poststmt = { simplestmt }
rangeclause = { (expressionlist ~ "=" | identifierlist ~ ":=")? ~ "range" ~ expression }
gostmt = { "go" ~ expression }
selectstmt = { "select" ~ "{" ~ (commclause)* ~ "}" }
commclause = { commcase ~ ":" ~ statementlist }
commcase = { "case" ~ (sendstmt | recvstmt) | "default" }
recvstmt = { (expressionlist ~ "=" | identifierlist ~ ":=")? ~ recvexpr }
recvexpr = { expression }
returnstmt = { "return" ~ (expressionlist)? }
breakstmt = { "break" ~ (label)? }
continuestmt = { "continue" ~ (label)? }
gotostmt = { "goto" ~ label }
fallthroughstmt = { "fallthrough" }
deferstmt = { "defer" ~ expression }
sourcefile = { packageclause ~ ";" ~ (importdecl ~ ";")* ~ (topleveldecl ~ ";")* }
packageclause = { "package" ~ packagename }
packagename = { identifier }
importdecl = { "import" ~ (importspec | "(" ~ (importspec ~ ";")* ~ ")") }
importspec = { ("." | packagename)? ~ importpath }
importpath = { string_lit }